<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>O2: Basics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">O2
   &#160;<span id="projectnumber">1.2</span>
   </div>
   <div id="projectbrief">Inter-process communication system for media applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Basics</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structo2__msg__data.html">o2_msg_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data part of an O2 message  <a href="structo2__msg__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structo2__message.html">o2_message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an O2 message container  <a href="structo2__message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structo2__blob.html">o2_blob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for binary large object.  <a href="structo2__blob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniono2__arg.html">o2_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">union of all O2 parameter types  <a href="uniono2__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae181a4fce37df0b71d662c3c7ce033da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae181a4fce37df0b71d662c3c7ce033da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>O2_MALLOC</b>(x)&#160;&#160;&#160;o2_dbg_malloc(x, __FILE__, __LINE__)</td></tr>
<tr class="separator:gae181a4fce37df0b71d662c3c7ce033da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1308fa0433aa3bde9d4ddc351bee55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d1308fa0433aa3bde9d4ddc351bee55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>O2_FREE</b>(x)&#160;&#160;&#160;o2_dbg_free(x, __FILE__, __LINE__)</td></tr>
<tr class="separator:ga0d1308fa0433aa3bde9d4ddc351bee55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75139f6debcba405f7403055673a6682"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga75139f6debcba405f7403055673a6682"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>O2_CALLOC</b>(n,  s)&#160;&#160;&#160;<a class="el" href="group__basics.html#ga79be172875c36891de05e904c4be8d76">o2_dbg_calloc</a>((n), (s), __FILE__, __LINE__)</td></tr>
<tr class="separator:ga75139f6debcba405f7403055673a6682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278a43b7d80dbe29b7514427e79fa995"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga278a43b7d80dbe29b7514427e79fa995"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSG_DATA_LENGTH</b>(m)&#160;&#160;&#160;(((int32_t *) &amp;((m)-&gt;timestamp))[-1])</td></tr>
<tr class="separator:ga278a43b7d80dbe29b7514427e79fa995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22dcab1b6323a34f6587304996a45891"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga22dcab1b6323a34f6587304996a45891">WORD_ALIGN_PTR</a>(p)&#160;&#160;&#160;((char *) (((size_t) (p)) &amp; ~3))</td></tr>
<tr class="memdesc:ga22dcab1b6323a34f6587304996a45891"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type string from o2_msg_data_ptr  <a href="#ga22dcab1b6323a34f6587304996a45891">More...</a><br /></td></tr>
<tr class="separator:ga22dcab1b6323a34f6587304996a45891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160eee3aa016cd8ff6940db938be8c58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga160eee3aa016cd8ff6940db938be8c58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>O2_MSG_TYPES</b>(msg)&#160;&#160;&#160;<a class="el" href="group__basics.html#ga22dcab1b6323a34f6587304996a45891">WORD_ALIGN_PTR</a>((msg)-&gt;address + strlen((msg)-&gt;address) + 4) + 1;</td></tr>
<tr class="separator:ga160eee3aa016cd8ff6940db938be8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc673b5516b18a164b5977798cf9b50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga5cc673b5516b18a164b5977798cf9b50">o2_send</a>(path,  time, ...)              </td></tr>
<tr class="memdesc:ga5cc673b5516b18a164b5977798cf9b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and send O2 message with best effort protocol.  <a href="#ga5cc673b5516b18a164b5977798cf9b50">More...</a><br /></td></tr>
<tr class="separator:ga5cc673b5516b18a164b5977798cf9b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e138392a070ca4e285361859451ed3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga40e138392a070ca4e285361859451ed3">o2_send_cmd</a>(path,  time, ...)</td></tr>
<tr class="memdesc:ga40e138392a070ca4e285361859451ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and send an O2 message reliably.  <a href="#ga40e138392a070ca4e285361859451ed3">More...</a><br /></td></tr>
<tr class="separator:ga40e138392a070ca4e285361859451ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa38553f092bb619d41d5b13020bcc21d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa38553f092bb619d41d5b13020bcc21d"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a></td></tr>
<tr class="memdesc:gaa38553f092bb619d41d5b13020bcc21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">O2 timestamps are doubles representing seconds since the approximate start time of the application. <br /></td></tr>
<tr class="separator:gaa38553f092bb619d41d5b13020bcc21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24dae11e78b46688c7bb2893e73661f8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structo2__msg__data.html">o2_msg_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga24dae11e78b46688c7bb2893e73661f8">o2_msg_data</a></td></tr>
<tr class="memdesc:ga24dae11e78b46688c7bb2893e73661f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">data part of an O2 message  <a href="#ga24dae11e78b46688c7bb2893e73661f8">More...</a><br /></td></tr>
<tr class="separator:ga24dae11e78b46688c7bb2893e73661f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c41a132fbc241741d1acf6d434c27c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c41a132fbc241741d1acf6d434c27c8"></a>
typedef struct <a class="el" href="structo2__msg__data.html">o2_msg_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>o2_msg_data_ptr</b></td></tr>
<tr class="separator:ga2c41a132fbc241741d1acf6d434c27c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa83fbf8171cfa3ddbd7528b53ed3a36"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structo2__message.html">o2_message</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gaaa83fbf8171cfa3ddbd7528b53ed3a36">o2_message</a></td></tr>
<tr class="memdesc:gaaa83fbf8171cfa3ddbd7528b53ed3a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">an O2 message container  <a href="#gaaa83fbf8171cfa3ddbd7528b53ed3a36">More...</a><br /></td></tr>
<tr class="separator:gaaa83fbf8171cfa3ddbd7528b53ed3a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e781858b8fcb308d9b7d15bd59265d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80e781858b8fcb308d9b7d15bd59265d"></a>
typedef struct <a class="el" href="structo2__message.html">o2_message</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>o2_message_ptr</b></td></tr>
<tr class="separator:ga80e781858b8fcb308d9b7d15bd59265d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc4fdfd7bc8ede272b84a4a3b441d45"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structo2__blob.html">o2_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gaedc4fdfd7bc8ede272b84a4a3b441d45">o2_blob</a></td></tr>
<tr class="memdesc:gaedc4fdfd7bc8ede272b84a4a3b441d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure for binary large object.  <a href="#gaedc4fdfd7bc8ede272b84a4a3b441d45">More...</a><br /></td></tr>
<tr class="separator:gaedc4fdfd7bc8ede272b84a4a3b441d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0dd4f5b958ff432f0353cdbb93dd569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad0dd4f5b958ff432f0353cdbb93dd569"></a>
typedef struct <a class="el" href="structo2__blob.html">o2_blob</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>o2_blob_ptr</b></td></tr>
<tr class="separator:gad0dd4f5b958ff432f0353cdbb93dd569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b38566beb37c0e45d4080bb498e38fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b38566beb37c0e45d4080bb498e38fe"></a>
typedef enum <a class="el" href="group__basics.html#gadf84af81a4f69b65b351008e3146279f">o2_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>o2_type_ptr</b></td></tr>
<tr class="separator:ga9b38566beb37c0e45d4080bb498e38fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6e542131a1f04cec65f3ffe0972b15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0f6e542131a1f04cec65f3ffe0972b15"></a>
typedef union <a class="el" href="uniono2__arg.html">o2_arg</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>o2_arg_ptr</b></td></tr>
<tr class="separator:ga0f6e542131a1f04cec65f3ffe0972b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c378242c7b1a32846b0bbbfa6d795a7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga1c378242c7b1a32846b0bbbfa6d795a7">o2_method_handler</a>) (const <a class="el" href="structo2__msg__data.html">o2_msg_data_ptr</a> msg, const char *types, <a class="el" href="uniono2__arg.html">o2_arg_ptr</a> *argv, int argc, void *user_data)</td></tr>
<tr class="memdesc:ga1c378242c7b1a32846b0bbbfa6d795a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback function to receive an O2 message  <a href="#ga1c378242c7b1a32846b0bbbfa6d795a7">More...</a><br /></td></tr>
<tr class="separator:ga1c378242c7b1a32846b0bbbfa6d795a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cba21d502e29060f7eb97c3c0f32ad5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga4cba21d502e29060f7eb97c3c0f32ad5">o2_time_callback</a>) (void *rock)</td></tr>
<tr class="memdesc:ga4cba21d502e29060f7eb97c3c0f32ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">signature for callback that defines the master clock  <a href="#ga4cba21d502e29060f7eb97c3c0f32ad5">More...</a><br /></td></tr>
<tr class="separator:ga4cba21d502e29060f7eb97c3c0f32ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadf84af81a4f69b65b351008e3146279f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gadf84af81a4f69b65b351008e3146279f">o2_type</a> { <br />
&#160;&#160;<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa7a4c57b8137f8280de6cdd1bb1951c12">O2_INT32</a> = 'i', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa36445ddc38bfabea7da89311dcbe0843">O2_FLOAT</a> = 'f', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fafb51c29c1efbe3794953c0cdfe180a5b">O2_STRING</a> = 's', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa1416d3f2dd4c6f914098e74f0a0d6f06">O2_BLOB</a> = 'b', 
<br />
&#160;&#160;<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa8f64d150c7b66c5d56c037ca24574141">O2_ARRAY_START</a> = '[', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa0ed7c5aa8b1e277236bf69b7af2dcc14">O2_ARRAY_END</a> = ']', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fab33367773fe8a452db20bc8a0d64f43a">O2_INT64</a> = 'h', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa620275e0ad74e722a7bbeaaaeed7c485">O2_TIME</a> = 't', 
<br />
&#160;&#160;<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa55a97103f771efb8d069ce96f1f3aae2">O2_DOUBLE</a> = 'd', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fad1e4a9e86d6650d94fe60560a65810c6">O2_SYMBOL</a> = 'S', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa68ce15f9ecf7e16ecdff2ca586d194ff">O2_CHAR</a> = 'c', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa3ed8c9bc23634e4e81085058be72d2ff">O2_MIDI</a> = 'm', 
<br />
&#160;&#160;<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa1f0e8a8c2b8210393c50edf1b59f0f4a">O2_TRUE</a> = 'T', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa1ae420af9879c921626c652a9c6c08fb">O2_FALSE</a> = 'F', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa97ff1cef0b98c5b58c976146bf2fb179">O2_NIL</a> = 'N', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa225f76ad8b11f51a5a9fb967edbe9723">O2_INFINITUM</a> = 'I', 
<br />
&#160;&#160;<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fac271ebf88f44f17c91291e46fc97e477">O2_BOOL</a> = 'B', 
<a class="el" href="group__basics.html#ggadf84af81a4f69b65b351008e3146279fa3104301cbfa6daaf59b0d5cef0bf9214">O2_VECTOR</a> = 'v'
<br />
 }<tr class="memdesc:gadf84af81a4f69b65b351008e3146279f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration of the O2 message types.  <a href="group__basics.html#gadf84af81a4f69b65b351008e3146279f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gadf84af81a4f69b65b351008e3146279f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad8310a36b8a7b1171497d9f0d0ec2626"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8310a36b8a7b1171497d9f0d0ec2626"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>o2_dbg_malloc</b> (size_t size, char *file, int line)</td></tr>
<tr class="separator:gad8310a36b8a7b1171497d9f0d0ec2626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bfaaad4d11ed32e8da7ffa7627fe9e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5bfaaad4d11ed32e8da7ffa7627fe9e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>o2_dbg_free</b> (void *obj, char *file, int line)</td></tr>
<tr class="separator:ga5bfaaad4d11ed32e8da7ffa7627fe9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79be172875c36891de05e904c4be8d76"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga79be172875c36891de05e904c4be8d76">o2_dbg_calloc</a> (size_t n, size_t s, char *file, int line)</td></tr>
<tr class="memdesc:ga79be172875c36891de05e904c4be8d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory  <a href="#ga79be172875c36891de05e904c4be8d76">More...</a><br /></td></tr>
<tr class="separator:ga79be172875c36891de05e904c4be8d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54991832ea34fc9a0a14b5a6669c3e6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga54991832ea34fc9a0a14b5a6669c3e6c">o2_initialize</a> (const char *application_name)</td></tr>
<tr class="memdesc:ga54991832ea34fc9a0a14b5a6669c3e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start O2.  <a href="#ga54991832ea34fc9a0a14b5a6669c3e6c">More...</a><br /></td></tr>
<tr class="separator:ga54991832ea34fc9a0a14b5a6669c3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9593ab20376d20759f3003e16af42838"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga9593ab20376d20759f3003e16af42838">o2_memory</a> (void *((*malloc)(size_t size)), void((*free)(void *)))</td></tr>
<tr class="memdesc:ga9593ab20376d20759f3003e16af42838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell O2 how to allocate/free memory.  <a href="#ga9593ab20376d20759f3003e16af42838">More...</a><br /></td></tr>
<tr class="separator:ga9593ab20376d20759f3003e16af42838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bd6f43cf100d78b5e2282409fc63a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga33bd6f43cf100d78b5e2282409fc63a0">o2_set_discovery_period</a> (<a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a> period)</td></tr>
<tr class="memdesc:ga33bd6f43cf100d78b5e2282409fc63a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set discovery period.  <a href="#ga33bd6f43cf100d78b5e2282409fc63a0">More...</a><br /></td></tr>
<tr class="separator:ga33bd6f43cf100d78b5e2282409fc63a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed73746128098a0fcb54224a43755cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd">o2_hub</a> (const char *ipaddress, int port)</td></tr>
<tr class="memdesc:gaaed73746128098a0fcb54224a43755cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a hub.  <a href="#gaaed73746128098a0fcb54224a43755cd">More...</a><br /></td></tr>
<tr class="separator:gaaed73746128098a0fcb54224a43755cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5567b921081dfade1c5f447ed20d201e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga5567b921081dfade1c5f447ed20d201e">o2_get_address</a> (const char **ipaddress, int *port)</td></tr>
<tr class="memdesc:ga5567b921081dfade1c5f447ed20d201e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get IP address and TCP connection port number.  <a href="#ga5567b921081dfade1c5f447ed20d201e">More...</a><br /></td></tr>
<tr class="separator:ga5567b921081dfade1c5f447ed20d201e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd22196d91300f33ba67d596549d2a69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gacd22196d91300f33ba67d596549d2a69">o2_service_new</a> (const char *service_name)</td></tr>
<tr class="memdesc:gacd22196d91300f33ba67d596549d2a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a service to the current application.  <a href="#gacd22196d91300f33ba67d596549d2a69">More...</a><br /></td></tr>
<tr class="separator:gacd22196d91300f33ba67d596549d2a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9323c695fd37d9a5ff063ee60493823"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gac9323c695fd37d9a5ff063ee60493823">o2_tap</a> (const char *tappee, const char *tapper)</td></tr>
<tr class="memdesc:gac9323c695fd37d9a5ff063ee60493823"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy messages from one service to another  <a href="#gac9323c695fd37d9a5ff063ee60493823">More...</a><br /></td></tr>
<tr class="separator:gac9323c695fd37d9a5ff063ee60493823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga316a1d88c3c728d6c0a4ba49228a8f35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga316a1d88c3c728d6c0a4ba49228a8f35">o2_service_free</a> (char *service_name)</td></tr>
<tr class="memdesc:ga316a1d88c3c728d6c0a4ba49228a8f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a local service.  <a href="#ga316a1d88c3c728d6c0a4ba49228a8f35">More...</a><br /></td></tr>
<tr class="separator:ga316a1d88c3c728d6c0a4ba49228a8f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5681e480b085ea6552a2456f1a3709de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga5681e480b085ea6552a2456f1a3709de">o2_method_new</a> (const char *path, const char *typespec, <a class="el" href="group__basics.html#ga1c378242c7b1a32846b0bbbfa6d795a7">o2_method_handler</a> h, void *user_data, int coerce, int parse)</td></tr>
<tr class="memdesc:ga5681e480b085ea6552a2456f1a3709de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler for an address.  <a href="#ga5681e480b085ea6552a2456f1a3709de">More...</a><br /></td></tr>
<tr class="separator:ga5681e480b085ea6552a2456f1a3709de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga086b104222177b13c3d8e2b47ec9bf28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga086b104222177b13c3d8e2b47ec9bf28">o2_poll</a> ()</td></tr>
<tr class="memdesc:ga086b104222177b13c3d8e2b47ec9bf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process current O2 messages.  <a href="#ga086b104222177b13c3d8e2b47ec9bf28">More...</a><br /></td></tr>
<tr class="separator:ga086b104222177b13c3d8e2b47ec9bf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cc834b5c8ee8200729ae0ec93f6a4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga98cc834b5c8ee8200729ae0ec93f6a4e">o2_run</a> (int rate)</td></tr>
<tr class="memdesc:ga98cc834b5c8ee8200729ae0ec93f6a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run O2.  <a href="#ga98cc834b5c8ee8200729ae0ec93f6a4e">More...</a><br /></td></tr>
<tr class="separator:ga98cc834b5c8ee8200729ae0ec93f6a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46819340ca66f61bb17059e5542f763a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga46819340ca66f61bb17059e5542f763a">o2_status</a> (const char *service)</td></tr>
<tr class="memdesc:ga46819340ca66f61bb17059e5542f763a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of the service.  <a href="#ga46819340ca66f61bb17059e5542f763a">More...</a><br /></td></tr>
<tr class="separator:ga46819340ca66f61bb17059e5542f763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0c061d57a3f5413f703cb479226752"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gafe0c061d57a3f5413f703cb479226752">o2_roundtrip</a> (double *mean, double *min)</td></tr>
<tr class="memdesc:gafe0c061d57a3f5413f703cb479226752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get network round-trip information.  <a href="#gafe0c061d57a3f5413f703cb479226752">More...</a><br /></td></tr>
<tr class="separator:gafe0c061d57a3f5413f703cb479226752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd34ca951dd2889063c3167e90799732"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gadd34ca951dd2889063c3167e90799732">o2_clock_set</a> (<a class="el" href="group__basics.html#ga4cba21d502e29060f7eb97c3c0f32ad5">o2_time_callback</a> gettime, void *rock)</td></tr>
<tr class="memdesc:gadd34ca951dd2889063c3167e90799732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a time reference to O2.  <a href="#gadd34ca951dd2889063c3167e90799732">More...</a><br /></td></tr>
<tr class="separator:gadd34ca951dd2889063c3167e90799732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7546187d25f2de9550078ddae9ce504e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga7546187d25f2de9550078ddae9ce504e">o2_message_send</a> (<a class="el" href="structo2__message.html">o2_message_ptr</a> msg)</td></tr>
<tr class="memdesc:ga7546187d25f2de9550078ddae9ce504e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an O2 message. (See also macros <a class="el" href="group__basics.html#ga5cc673b5516b18a164b5977798cf9b50" title="Construct and send O2 message with best effort protocol. ">o2_send</a> and <a class="el" href="group__basics.html#ga40e138392a070ca4e285361859451ed3" title="Construct and send an O2 message reliably. ">o2_send_cmd</a>).  <a href="#ga7546187d25f2de9550078ddae9ce504e">More...</a><br /></td></tr>
<tr class="separator:ga7546187d25f2de9550078ddae9ce504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10db3d64aa464498b6b8b90c28b7996d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga10db3d64aa464498b6b8b90c28b7996d">o2_time_get</a> ()</td></tr>
<tr class="memdesc:ga10db3d64aa464498b6b8b90c28b7996d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the estimated synchronized global O2 time.  <a href="#ga10db3d64aa464498b6b8b90c28b7996d">More...</a><br /></td></tr>
<tr class="separator:ga10db3d64aa464498b6b8b90c28b7996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad61265502fc27fb2e145171be3b3cf0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gad61265502fc27fb2e145171be3b3cf0a">o2_local_time</a> ()</td></tr>
<tr class="memdesc:gad61265502fc27fb2e145171be3b3cf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real time using the local O2 clock.  <a href="#gad61265502fc27fb2e145171be3b3cf0a">More...</a><br /></td></tr>
<tr class="separator:gad61265502fc27fb2e145171be3b3cf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b4fc40e23deec5c8a311aefec391d7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga67b4fc40e23deec5c8a311aefec391d7">o2_error_to_string</a> (int i)</td></tr>
<tr class="memdesc:ga67b4fc40e23deec5c8a311aefec391d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return text representation of an O2 error.  <a href="#ga67b4fc40e23deec5c8a311aefec391d7">More...</a><br /></td></tr>
<tr class="separator:ga67b4fc40e23deec5c8a311aefec391d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0a8ba7f6be0f8f95ad7e7803fa0698"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gaeb0a8ba7f6be0f8f95ad7e7803fa0698">o2_finish</a> ()</td></tr>
<tr class="memdesc:gaeb0a8ba7f6be0f8f95ad7e7803fa0698"><td class="mdescLeft">&#160;</td><td class="mdescRight">release the memory and shut down O2.  <a href="#gaeb0a8ba7f6be0f8f95ad7e7803fa0698">More...</a><br /></td></tr>
<tr class="separator:gaeb0a8ba7f6be0f8f95ad7e7803fa0698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3dd4a4c5cb37fa0926848f57a86cd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga5a3dd4a4c5cb37fa0926848f57a86cd2">o2_osc_port_new</a> (const char *service_name, int port_num, int tcp_flag)</td></tr>
<tr class="memdesc:ga5a3dd4a4c5cb37fa0926848f57a86cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a port to receive OSC messages.  <a href="#ga5a3dd4a4c5cb37fa0926848f57a86cd2">More...</a><br /></td></tr>
<tr class="separator:ga5a3dd4a4c5cb37fa0926848f57a86cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4500742eecb51b9800c762dfb65348d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gad4500742eecb51b9800c762dfb65348d">o2_osc_port_free</a> (int port_num)</td></tr>
<tr class="memdesc:gad4500742eecb51b9800c762dfb65348d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a port receiving OSC messages.  <a href="#gad4500742eecb51b9800c762dfb65348d">More...</a><br /></td></tr>
<tr class="separator:gad4500742eecb51b9800c762dfb65348d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4744322896863a159a920ce798fe718"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gac4744322896863a159a920ce798fe718">o2_osc_delegate</a> (const char *service_name, const char *ip, int port_num, int tcp_flag)</td></tr>
<tr class="memdesc:gac4744322896863a159a920ce798fe718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a service that forwards O2 messages to an OSC server.  <a href="#gac4744322896863a159a920ce798fe718">More...</a><br /></td></tr>
<tr class="separator:gac4744322896863a159a920ce798fe718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34537bc20e5ea607f28da63867452284"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga34537bc20e5ea607f28da63867452284">o2_osc_time_offset</a> (uint64_t offset)</td></tr>
<tr class="memdesc:ga34537bc20e5ea607f28da63867452284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the OSC time offset.  <a href="#ga34537bc20e5ea607f28da63867452284">More...</a><br /></td></tr>
<tr class="separator:ga34537bc20e5ea607f28da63867452284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb3e18653c5cd78174042c75e7da8b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga2bb3e18653c5cd78174042c75e7da8b2">o2_schedule</a> (o2_sched_ptr scheduler, <a class="el" href="structo2__message.html">o2_message_ptr</a> msg)</td></tr>
<tr class="separator:ga2bb3e18653c5cd78174042c75e7da8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf9b8301fa8d6d417e8c1b904b85eb41e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9b8301fa8d6d417e8c1b904b85eb41e"></a>
<a class="el" href="uniono2__arg.html">o2_arg_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>o2_got_start_array</b></td></tr>
<tr class="separator:gaf9b8301fa8d6d417e8c1b904b85eb41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa244f5c43db935acc4350ea51e77882f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa244f5c43db935acc4350ea51e77882f"></a>
<a class="el" href="uniono2__arg.html">o2_arg_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>o2_got_end_array</b></td></tr>
<tr class="separator:gaa244f5c43db935acc4350ea51e77882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e8255411b99815dcb37bd5da8b0427"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gaa3e8255411b99815dcb37bd5da8b0427">o2_application_name</a></td></tr>
<tr class="memdesc:gaa3e8255411b99815dcb37bd5da8b0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">name of the application  <a href="#gaa3e8255411b99815dcb37bd5da8b0427">More...</a><br /></td></tr>
<tr class="separator:gaa3e8255411b99815dcb37bd5da8b0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0148f5dab667f58540f2f2ce1074aa88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga0148f5dab667f58540f2f2ce1074aa88">o2_stop_flag</a></td></tr>
<tr class="memdesc:ga0148f5dab667f58540f2f2ce1074aa88"><td class="mdescLeft">&#160;</td><td class="mdescRight">set this flag to stop <a class="el" href="group__basics.html#ga98cc834b5c8ee8200729ae0ec93f6a4e" title="Run O2. ">o2_run()</a>  <a href="#ga0148f5dab667f58540f2f2ce1074aa88">More...</a><br /></td></tr>
<tr class="separator:ga0148f5dab667f58540f2f2ce1074aa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc6760fd6ddcbcb20f99306b83c5b85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaafc6760fd6ddcbcb20f99306b83c5b85"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#gaafc6760fd6ddcbcb20f99306b83c5b85">o2_clock_is_synchronized</a></td></tr>
<tr class="memdesc:gaafc6760fd6ddcbcb20f99306b83c5b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable indicating that the clock is the master or is synchronized to the master. <br /></td></tr>
<tr class="separator:gaafc6760fd6ddcbcb20f99306b83c5b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a5538a2b701920639e89be06ad8d49"><td class="memItemLeft" align="right" valign="top">o2_sched&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga12a5538a2b701920639e89be06ad8d49">o2_gtsched</a></td></tr>
<tr class="memdesc:ga12a5538a2b701920639e89be06ad8d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler that schedules according to global (master) clock time.  <a href="#ga12a5538a2b701920639e89be06ad8d49">More...</a><br /></td></tr>
<tr class="separator:ga12a5538a2b701920639e89be06ad8d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a8e27a3d04e922c4903e54f3399752"><td class="memItemLeft" align="right" valign="top">o2_sched&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga65a8e27a3d04e922c4903e54f3399752">o2_ltsched</a></td></tr>
<tr class="memdesc:ga65a8e27a3d04e922c4903e54f3399752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler that schedules according to local clock time.  <a href="#ga65a8e27a3d04e922c4903e54f3399752">More...</a><br /></td></tr>
<tr class="separator:ga65a8e27a3d04e922c4903e54f3399752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91fe84d524309a27b579ea169d5816ae"><td class="memItemLeft" align="right" valign="top">o2_sched_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__basics.html#ga91fe84d524309a27b579ea169d5816ae">o2_active_sched</a></td></tr>
<tr class="memdesc:ga91fe84d524309a27b579ea169d5816ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current scheduler.  <a href="#ga91fe84d524309a27b579ea169d5816ae">More...</a><br /></td></tr>
<tr class="separator:ga91fe84d524309a27b579ea169d5816ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga5cc673b5516b18a164b5977798cf9b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define o2_send</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">path, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">time, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and send O2 message with best effort protocol. </p>
<p>Normally, this constructs and sends an O2 message via UDP. If the destination service is reached via some other network protocol (e.g. Bluetooth), the message is delivered in the lowest latency protocol available, with no guaranteed delivery.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>an address pattern </td></tr>
    <tr><td class="paramname">time</td><td>when to dispatch the message, 0 means right now. In any case, the message is sent to the receiving service as soon as possible. If the message arrives early, it will be held at the service and dispatched as soon as possible after the indicated time. </td></tr>
    <tr><td class="paramname">typestring</td><td>the type string for the message. Each character indicates one data item. Type codes are as in OSC. </td></tr>
    <tr><td class="paramname">...</td><td>the data of the message. There is one parameter for each character in the typestring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga40e138392a070ca4e285361859451ed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define o2_send_cmd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">path, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">time, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and send an O2 message reliably. </p>
<p>Normally, this constructs and sends an O2 message via TCP. If the destination service is reached via some other network protocol (e.g. Bluetooth), the message is delivered using the most reliable protocol available. (Thus, this call is considered a "hint" rather than an absolute requirement.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>an address pattern </td></tr>
    <tr><td class="paramname">time</td><td>when to dispatch the message, 0 means right now. In any case, the message is sent to the receiving service as soon as possible. If the message arrives early, it will be held at the service and dispatched as soon as possible after the indicated time. </td></tr>
    <tr><td class="paramname">typestring</td><td>the type string for the message. Each character indicates one data item. Type codes are defined by <a class="el" href="group__basics.html#gadf84af81a4f69b65b351008e3146279f" title="An enumeration of the O2 message types. ">o2_type</a>. </td></tr>
    <tr><td class="paramname">...</td><td>the data of the message. There is one parameter for each character in the typestring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22dcab1b6323a34f6587304996a45891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORD_ALIGN_PTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p</td><td>)</td>
          <td>&#160;&#160;&#160;((char *) (((size_t) (p)) &amp; ~3))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the type string from o2_msg_data_ptr </p>
<p>Type strings begin with the comma (",") character, which is skipped </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaedc4fdfd7bc8ede272b84a4a3b441d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structo2__blob.html">o2_blob</a>  <a class="el" href="structo2__blob.html">o2_blob</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The structure for binary large object. </p>
<p>A blob can be passed in an O2 message using the 'b' type. Created by calls to <a class="el" href="group__lowlevelsend.html#ga7200a8dc9042c32e863c036b8d950266" title="Allocate a blob. ">o2_blob_new()</a>. </p>

</div>
</div>
<a class="anchor" id="gaaa83fbf8171cfa3ddbd7528b53ed3a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structo2__message.html">o2_message</a>  <a class="el" href="structo2__message.html">o2_message</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an O2 message container </p>
<p>Note: This struct represents an O2 message that is stored on the heap. The length field must preceded data with no padding (see <a class="el" href="structo2__msg__data.html" title="data part of an O2 message ">o2_msg_data</a> declaration and the note that precedes it). To make sure there is no padding between length and data, we force the next pointer to occupy 8 bytes even if this is a 32-bit machine by making it part of a union with an 8-byte int64_t field named "pad_if_needed."</p>
<p>Note that o2_messages are on the heap and can be allocated, scheduled, sent, and freed. In contrast, <a class="el" href="structo2__msg__data.html" title="data part of an O2 message ">o2_msg_data</a> structures are contained within o2_messages and are passed to method handlers, but cannot be allocated, scheduled, sent, or freed. They are always the data field of a containing <a class="el" href="structo2__message.html" title="an O2 message container ">o2_message</a>. </p>

</div>
</div>
<a class="anchor" id="ga1c378242c7b1a32846b0bbbfa6d795a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* o2_method_handler) (const <a class="el" href="structo2__msg__data.html">o2_msg_data_ptr</a> msg, const char *types, <a class="el" href="uniono2__arg.html">o2_arg_ptr</a> *argv, int argc, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>callback function to receive an O2 message </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The full message in host byte order. </td></tr>
    <tr><td class="paramname">types</td><td>If you set a type string in your method creation call, then this type string is provided here. If you did not specify a string, types will be the type string from the message (without the initial ','). If parse_args and coerce_flag were set in the method creation call, types will match the types in argv, but not necessarily the type string or types in msg. </td></tr>
    <tr><td class="paramname">argv</td><td>An array of <a class="el" href="uniono2__arg.html" title="union of all O2 parameter types ">o2_arg</a> types containing the values, e.g. if the first argument of the incoming message is of type 'f' then the value will be found in argv[0]-&gt;f. (If parse_args was not set in the method creation call, argv will be NULL.) For vectors, specified in types by the sequence "vi", "vh", "vf", or "vd", there will be one pointer in argv pointing to a vector description (the v field in <a class="el" href="uniono2__arg.html" title="union of all O2 parameter types ">o2_arg</a>). For arrays, there are <em>no</em> pointers corresponding to '[' or ']' in the types string; but there is one pointer in argv for each array element. </td></tr>
    <tr><td class="paramname">argc</td><td>The number of arguments received. (This is valid even if parse_args was not set in the method creation call.) This is the length of argv. Vectors count as one, array elements count as one each, and arrays themselves are not represented. For example, an empty array ("[]") in the type string adds nothing to the argc count or argv vector. </td></tr>
    <tr><td class="paramname">user_data</td><td>This contains the user_data value passed in the call to the method creation call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24dae11e78b46688c7bb2893e73661f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structo2__msg__data.html">o2_msg_data</a>  <a class="el" href="structo2__msg__data.html">o2_msg_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>data part of an O2 message </p>
<p>This data type is used to pass o2 message data to message handlers. It appears many other times in the code. You should NEVER allocate or free an <a class="el" href="structo2__msg__data.html" title="data part of an O2 message ">o2_msg_data</a> struct. Instead, create a message using <a class="el" href="group__lowlevelsend.html#gaba2bb68cca429072d4968c14df144e50" title="Prepare to build a message. ">o2_send_start()</a>, o2_add_*(), and <a class="el" href="group__lowlevelsend.html#ga5ba4980bb0fbbaa19ce6c518ad081271" title="finish and return the message. ">o2_message_finish()</a> to get an o2_message_ptr. Within the <a class="el" href="structo2__message.html" title="an O2 message container ">o2_message</a>, the data field is an <a class="el" href="structo2__msg__data.html" title="data part of an O2 message ">o2_msg_data</a> structure. We would use <a class="el" href="structo2__message.html" title="an O2 message container ">o2_message</a> everywhere instead of <a class="el" href="structo2__msg__data.html" title="data part of an O2 message ">o2_msg_data</a>, but bundles can contain multiple <a class="el" href="structo2__msg__data.html" title="data part of an O2 message ">o2_msg_data</a> structures without the extra baggage contained in an <a class="el" href="structo2__message.html" title="an O2 message container ">o2_message</a>.</p>
<p>Note: it is assumed that an <a class="el" href="structo2__msg__data.html" title="data part of an O2 message ">o2_msg_data</a> struct is always preceded by a 32-bit length. Ideally, length should therefore be in this struct, but then the compiler might add padding to put the timestamp on an 8-byte alignment. This could be solved with a pack pragma, but that is not standard C. To be safe and portable, I decided to just leave length out of the struct. The macro MSG_DATA_LENGTH can be used to access the length field. </p>

</div>
</div>
<a class="anchor" id="ga4cba21d502e29060f7eb97c3c0f32ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a>(* o2_time_callback) (void *rock)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signature for callback that defines the master clock </p>
<p>See <a class="el" href="group__basics.html#gadd34ca951dd2889063c3167e90799732" title="Provide a time reference to O2. ">o2_clock_set()</a> for details. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gadf84af81a4f69b65b351008e3146279f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__basics.html#gadf84af81a4f69b65b351008e3146279f">o2_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enumeration of the O2 message types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa7a4c57b8137f8280de6cdd1bb1951c12"></a>O2_INT32&#160;</td><td class="fielddoc">
<p>32 bit signed integer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa36445ddc38bfabea7da89311dcbe0843"></a>O2_FLOAT&#160;</td><td class="fielddoc">
<p>32 bit IEEE-754 float. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fafb51c29c1efbe3794953c0cdfe180a5b"></a>O2_STRING&#160;</td><td class="fielddoc">
<p>NULL terminated string (Standard C). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa1416d3f2dd4c6f914098e74f0a0d6f06"></a>O2_BLOB&#160;</td><td class="fielddoc">
<p>Binary Large OBject (BLOB) type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa8f64d150c7b66c5d56c037ca24574141"></a>O2_ARRAY_START&#160;</td><td class="fielddoc">
<p>Start array or tuple. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa0ed7c5aa8b1e277236bf69b7af2dcc14"></a>O2_ARRAY_END&#160;</td><td class="fielddoc">
<p>End array or tuple. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fab33367773fe8a452db20bc8a0d64f43a"></a>O2_INT64&#160;</td><td class="fielddoc">
<p>64 bit signed integer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa620275e0ad74e722a7bbeaaaeed7c485"></a>O2_TIME&#160;</td><td class="fielddoc">
<p>OSC time type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa55a97103f771efb8d069ce96f1f3aae2"></a>O2_DOUBLE&#160;</td><td class="fielddoc">
<p>64 bit IEEE-754 double. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fad1e4a9e86d6650d94fe60560a65810c6"></a>O2_SYMBOL&#160;</td><td class="fielddoc">
<p>Used in systems distinguish strings and symbols. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa68ce15f9ecf7e16ecdff2ca586d194ff"></a>O2_CHAR&#160;</td><td class="fielddoc">
<p>8bit char variable (Standard C). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa3ed8c9bc23634e4e81085058be72d2ff"></a>O2_MIDI&#160;</td><td class="fielddoc">
<p>4 byte MIDI packet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa1f0e8a8c2b8210393c50edf1b59f0f4a"></a>O2_TRUE&#160;</td><td class="fielddoc">
<p>Symbol representing the value True. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa1ae420af9879c921626c652a9c6c08fb"></a>O2_FALSE&#160;</td><td class="fielddoc">
<p>Symbol representing the value False. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa97ff1cef0b98c5b58c976146bf2fb179"></a>O2_NIL&#160;</td><td class="fielddoc">
<p>Symbol representing the value Nil. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa225f76ad8b11f51a5a9fb967edbe9723"></a>O2_INFINITUM&#160;</td><td class="fielddoc">
<p>Symbol representing the value Infinitum. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fac271ebf88f44f17c91291e46fc97e477"></a>O2_BOOL&#160;</td><td class="fielddoc">
<p>Boolean value returned as either 0 or 1. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf84af81a4f69b65b351008e3146279fa3104301cbfa6daaf59b0d5cef0bf9214"></a>O2_VECTOR&#160;</td><td class="fielddoc">
<p>Prefix to indicate a vector. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gadd34ca951dd2889063c3167e90799732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_clock_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__basics.html#ga4cba21d502e29060f7eb97c3c0f32ad5">o2_time_callback</a>&#160;</td>
          <td class="paramname"><em>gettime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a time reference to O2. </p>
<p>Exactly one process per O2 application should provide a master clock. All other processes synchronize to the master. To become the master, call <a class="el" href="group__basics.html#gadd34ca951dd2889063c3167e90799732" title="Provide a time reference to O2. ">o2_clock_set()</a>.</p>
<p>The time reported by the gettime function will be offset to match the current local time so that local time continues to increase smoothly. You cannot force O2 time to match an external absolute time, but once <a class="el" href="group__basics.html#gadd34ca951dd2889063c3167e90799732" title="Provide a time reference to O2. ">o2_clock_set()</a> is called, the difference between the time reference and O2's local time (as reported by <a class="el" href="group__basics.html#gad61265502fc27fb2e145171be3b3cf0a" title="Get the real time using the local O2 clock. ">o2_local_time()</a>) will be fixed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gettime</td><td>function to get the time in units of seconds. The reference may be operating system time, audio system time, MIDI system time, or any other time source. The times returned by this function must be non-decreasing and must increase by one second per second of real time to close approximation. The value may be NULL, in which case a default time reference will be used.</td></tr>
  </table>
  </dd>
</dl>
<p>rock an arbitrary value that is passed to the gettime function. This may be need to provide context. Use NULL if no context is required.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79be172875c36891de05e904c4be8d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* o2_dbg_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate memory </p>
<p>O2 allows you to provide custom heap implementations to avoid priority inversion or other real-time problems. Normally, you should not need to explicitly allocate memory since O2 functions are provided to allocate, construct, and deallocate messages, but if you need to allocate memory, especially in an O2 message handler callback, i.e. within the sphere of O2 execution, you should use #O2_MALLOC, #O2_FREE, and #O2_CALLOC.free memory allocated by #O2_MALLOC allocate and zero memory (see #O2_MALLOC) </p>

</div>
</div>
<a class="anchor" id="ga67b4fc40e23deec5c8a311aefec391d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* o2_error_to_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return text representation of an O2 error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>error number returned from some O2 function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the error message as a string </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb0a8ba7f6be0f8f95ad7e7803fa0698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release the memory and shut down O2. </p>
<p>Close all sockets, free all memory, and restore critical variables so that O2 behaves as if it was never initialized.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5567b921081dfade1c5f447ed20d201e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_get_address </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ipaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get IP address and TCP connection port number. </p>
<p>Before calling <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a>, you need to know the IP address and TCP connection port of another process. This call will retrieve the information, but the mechanism to transfer this information to another O2 process (or all of them) must be implemented outside of O2. (If the local network allows UDP broadcast and all hosts are on the local network, then you do not need this function or <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a>. Instead, let the discovery protocol exchange process addresses automatically.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipaddress</td><td>is a pointer that will be set to either NULL (on failure) or a string of the form "128.2.10.6". The string should not be modified, and the string will be freed by O2 if <a class="el" href="group__basics.html#gaeb0a8ba7f6be0f8f95ad7e7803fa0698" title="release the memory and shut down O2. ">o2_finish()</a> is called.</td></tr>
    <tr><td class="paramname">port</td><td>will be set to a pointer to the O2 TCP connection port (or NULL on failure).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaed73746128098a0fcb54224a43755cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_hub </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ipaddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a hub. </p>
<p>A "hub" is an O2 process that shares discovery information with other processes. This is an alternate form of discovery that is completely compatible with the broadcast-based discovery protocol, except (1) you do not need broadcast messages to communicate with a hub, (2) you <em>do</em> need the hub's IP address and port number. If the IP and port number can be shared, e.g. through a server or online database with a fixed address, you can work with networks that disallow broadcast, and you can connect across networks (which will not work with O2's normal discovery protocol if broadcast messages are not delivered across networks). To use a hub, you call <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a> with the hub's IP address and port. All O2 processes are effectively hubs with no clients, and <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a> simply connects to the hub as a client. The hub will then send discovery messages for all current and future O2 processes that are discovered, either through the normal discovery protocol or by connecting with the <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a> call.</p>
<p>After <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a> is called, discovery broadcasting is stopped, so if <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a> fails to connect to another process, you will only discover more processes if they initiate the exchange. You can use <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a> specifically to disable broadcast-based discovery by passing NULL as the ipaddress parameter.</p>
<p>You can call <a class="el" href="group__basics.html#gaaed73746128098a0fcb54224a43755cd" title="Connect to a hub. ">o2_hub()</a> multiple times. Each time potentially makes a remote process become a hub for this local process. This might result in duplicate messages when new processes join the O2 application, but duplicate messages are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipaddress</td><td>the IP address of the hub or NULL </td></tr>
    <tr><td class="paramname">port</td><td>the port number of the hub's TCP port</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54991832ea34fc9a0a14b5a6669c3e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_initialize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>application_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start O2. </p>
<p>If O2 has not been initialized, it is created and intialized. O2 will begin to establish connections to other instances with a matching application name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">application_name</td><td>the name of the application. O2 will attempt to discover other processes with a matching application name, ignoring all processes with non-matching names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if an error occurs, #O2_RUNNING if already running, <a class="el" href="group__returncodes.html#ga8c9ef89180c2df1a5aa09f3bda593742" title="an error return value for o2_initialize(): invalid name parameter. ">O2_BAD_NAME</a> if <code>application_name</code> is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gad61265502fc27fb2e145171be3b3cf0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a> o2_local_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real time using the local O2 clock. </p>
<dl class="section return"><dt>Returns</dt><dd>the local time in seconds </dd></dl>

</div>
</div>
<a class="anchor" id="ga9593ab20376d20759f3003e16af42838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">(*malloc)(size_t size), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void((*free)(void *))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell O2 how to allocate/free memory. </p>
<p>In many C library implementations, the standard implementation of free() must lock a data structure. This can lead to priority inversion if O2 runs at an elevated priority. Furthermore, the standard <code>malloc()</code> and <code>free()</code> do not run in constant (real) time. To avoid these problems, you can provide an alternate heap implementation for O2 by calling this function before calling <a class="el" href="group__basics.html#ga54991832ea34fc9a0a14b5a6669c3e6c" title="Start O2. ">o2_initialize()</a>. For example, the provided functions can implement a private heap for the thread running O2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc</td><td>a function pointer that behaves like standard <code>malloc()</code> </td></tr>
    <tr><td class="paramname">free</td><td>a function pointer that behaves like standard <code>free()</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>O2_SUCCESS if succeed, O2_FAIL if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7546187d25f2de9550078ddae9ce504e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_message_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structo2__message.html">o2_message_ptr</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an O2 message. (See also macros <a class="el" href="group__basics.html#ga5cc673b5516b18a164b5977798cf9b50" title="Construct and send O2 message with best effort protocol. ">o2_send</a> and <a class="el" href="group__basics.html#ga40e138392a070ca4e285361859451ed3" title="Construct and send an O2 message reliably. ">o2_send_cmd</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>points to an O2 message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not.</dd></dl>
<p>After the call, the <code>msg</code> parameter is "owned" by O2, which will free it. Therefore, do <em>not</em> free msg after calling <a class="el" href="group__basics.html#ga7546187d25f2de9550078ddae9ce504e" title="Send an O2 message. (See also macros o2_send and o2_send_cmd). ">o2_message_send()</a>. </p>

</div>
</div>
<a class="anchor" id="ga5681e480b085ea6552a2456f1a3709de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_method_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>typespec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__basics.html#ga1c378242c7b1a32846b0bbbfa6d795a7">o2_method_handler</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coerce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a handler for an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the address including the service name. If the address is only the service name with no trailing slash, the handler will match any message to the service. Addresses should not conflict: An address should not match another address, and for every pair of addresses X and Y, X/ should not be a prefix of Y. </td></tr>
    <tr><td class="paramname">typespec</td><td>the types of parameters, use "" for no parameters and NULL for no type checking </td></tr>
    <tr><td class="paramname">h</td><td>the handler </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer saved and passed to handler </td></tr>
    <tr><td class="paramname">coerce</td><td>is true if you want to allow automatic coercion of types. Coercion is only enabled if both coerce and parse are true. </td></tr>
    <tr><td class="paramname">parse</td><td>is true if you want O2 to construct an argv argument vector to pass to the handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>O2_SUCCESS if succeed, O2_FAIL if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4744322896863a159a920ce798fe718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_osc_delegate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tcp_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a service that forwards O2 messages to an OSC server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The o2 service name without a '/' prefix. </td></tr>
    <tr><td class="paramname">ip</td><td>The ip address of the osc server. </td></tr>
    <tr><td class="paramname">port_num</td><td>The port number of the osc server. </td></tr>
    <tr><td class="paramname">tcp_flag</td><td>Send OSC message via TCP protocol, in which case port_num is the TCP server port, not a connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not.</dd></dl>
<p>If <code>tcp_flag</code> is set, a TCP connection will be established with the OSC server. When the created service receives any O2 messages, it will send the message to the OSC server. If the incoming message has a timestamp for some future time, the message will be held until that time, then sent to the OSC server. (Ideally, O2 could convert the message to an OSC timestamped bundle and send it immediately to achieve precise forward-synchronous timing, but this requires clock synchronization with the OSC server, which is normally unimplemented.)</p>
<p>If this is a tcp connection, close it by calling <a class="el" href="group__basics.html#ga316a1d88c3c728d6c0a4ba49228a8f35" title="Remove a local service. ">o2_service_free()</a>. </p>

</div>
</div>
<a class="anchor" id="gad4500742eecb51b9800c762dfb65348d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_osc_port_free </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a port receiving OSC messages. </p>
<p>This removes a port created by <a class="el" href="group__basics.html#ga5a3dd4a4c5cb37fa0926848f57a86cd2" title="Create a port to receive OSC messages. ">o2_osc_port_new()</a>. If you want to remove the corresponding service, you must also call <a class="el" href="group__basics.html#ga316a1d88c3c728d6c0a4ba49228a8f35" title="Remove a local service. ">o2_service_free()</a> with the service name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_num</td><td>The port number that receives OSC messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a3dd4a4c5cb37fa0926848f57a86cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_osc_port_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tcp_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a port to receive OSC messages. </p>
<p>OSC messages are converted to O2 messages and directed to the service. E.g. if the service is "maxmsp" and the message address is <code>/foo/x</code>, then the message is directed to and handled by <code>/maxmsp/foo/x</code>. If the #service_name does not exist at any time after calling <a class="el" href="group__basics.html#ga5a3dd4a4c5cb37fa0926848f57a86cd2" title="Create a port to receive OSC messages. ">o2_osc_port_new</a>, incoming OSC messages will be dropped until the service is available again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name of the service to which messages are delivered </td></tr>
    <tr><td class="paramname">port_num</td><td>Port number. </td></tr>
    <tr><td class="paramname">tcp_flag</td><td>Be a TCP server for remote clients. Otherwise, use UDP</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34537bc20e5ea607f28da63867452284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t o2_osc_time_offset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the OSC time offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset between (global) O2 time and OSC time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous offset</dd></dl>
<p>O2 global time should start from 0.0 when the clock is started, whereas OSC time starts at 1 Jan 1900. The offset is the OSC time corresponding to O2 time 0.0. Equivalently, OSC_time = O2_time + offset. </p>

</div>
</div>
<a class="anchor" id="ga086b104222177b13c3d8e2b47ec9bf28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_poll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process current O2 messages. </p>
<p>Since O2 does not create a thread and O2 requires active processing to establish and maintain connections, the O2 programmer (user) should call <a class="el" href="group__basics.html#ga086b104222177b13c3d8e2b47ec9bf28" title="Process current O2 messages. ">o2_poll()</a> periodically, even if not offering a service. <a class="el" href="group__basics.html#ga086b104222177b13c3d8e2b47ec9bf28" title="Process current O2 messages. ">o2_poll()</a> runs a discovery protocol to find and connect to other processes, runs a clock synchronization protocol to establish valid time stamps, and handles incoming messages to all services. O2_poll() should be called at least 10 times per second. Messages can only be delivered during a call to <a class="el" href="group__basics.html#ga086b104222177b13c3d8e2b47ec9bf28" title="Process current O2 messages. ">o2_poll()</a> so more frequent calls will generally lower the message latency as well as the accuracy of the clock synchronization (at the cost of greater CPU utilization). Human perception of timing jitter is on the order of 10ms, so polling rates of 200 to 1000 are advised in situations where rhythmic accuracy is expected.</p>
<dl class="section return"><dt>Returns</dt><dd>0 (O2_SUCCESS) if succeed, -1 (O2_FAIL) if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe0c061d57a3f5413f703cb479226752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_roundtrip </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get network round-trip information. </p>
<dl class="section return"><dt>Returns</dt><dd>If clock is synchronized, return O2_SUCCESS and set <code>*mean</code> to the mean round-trip time and <code>*min</code> to the minimum round-trip time of the last 5 (where 5 is the value of CLOCK_SYNC_HISTORY_LEN) clock sync requests. Otherwise, O2_FAIL is returned and <code>*mean</code> and <code>*min</code> are unaltered.</dd></dl>
<p>Note: You can get this information from a remote process by sending a message to <code>!ip:port/cs/rt</code>, where <code>ip:port</code> is the ip:port string for a process. (One way to get this is to call <code>o2_get_address</code> and construct a ip:port process name from the information returned. But then you can just call <code>o2_roundtrip</code> for the local process round trip information. For a remote process names, you can create a handler for <code>/_o2/si</code>. The process name is provided whenever one of its services is created or otherwise changes status.) The type string for <code>!ip:port/cs/rt</code> is "s", and the parameter is an O2 address prefix. When the message is received, a reply is sent to an address formed by appending "/get-reply" to the address prefix. The reply message has the type string "sff", and the parameters are (1) the process ip:port name, (2) the mean of recent round trip times to the master clock, and (3) the minimum of recent round trip times. (The clock is set using the minimum, so this number is an upper bound on the clock skew for this process. </p>

</div>
</div>
<a class="anchor" id="ga98cc834b5c8ee8200729ae0ec93f6a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run O2. </p>
<p>Call <a class="el" href="group__basics.html#ga086b104222177b13c3d8e2b47ec9bf28" title="Process current O2 messages. ">o2_poll()</a> at the rate (in Hz) indicated. Returns if a handler sets <a class="el" href="group__basics.html#ga0148f5dab667f58540f2f2ce1074aa88" title="set this flag to stop o2_run() ">o2_stop_flag</a> to non-zero. </p>

</div>
</div>
<a class="anchor" id="ga2bb3e18653c5cd78174042c75e7da8b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_schedule </td>
          <td>(</td>
          <td class="paramtype">o2_sched_ptr&#160;</td>
          <td class="paramname"><em>scheduler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structo2__message.html">o2_message_ptr</a>&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>/brief Schedule a message.</p>
<p>Rather than sending a message, messages can be directly scheduled. This is particulary useful if you want to schedule activity before clock synchronization is achieved. For example, you might want to poll every second waiting for clock synchronization. In that case, you need to use the local scheduler (<a class="el" href="group__basics.html#ga65a8e27a3d04e922c4903e54f3399752" title="Scheduler that schedules according to local clock time. ">o2_ltsched</a>). <a class="el" href="group__basics.html#ga5cc673b5516b18a164b5977798cf9b50" title="Construct and send O2 message with best effort protocol. ">o2_send()</a> will use the global time scheduler (<a class="el" href="group__basics.html#ga12a5538a2b701920639e89be06ad8d49" title="Scheduler that schedules according to global (master) clock time. ">o2_gtsched</a>), so your only option is to construct a message and call <a class="el" href="group__basics.html#ga2bb3e18653c5cd78174042c75e7da8b2">o2_schedule()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>a pointer to a scheduler (<code>&amp;o2_ltsched</code> or <code>&amp;o2_gtsched</code>) </td></tr>
    <tr><td class="paramname">msg</td><td>a pointer to the message to schedule</td></tr>
  </table>
  </dd>
</dl>
<p>The message is scheduled for delivery according to its timestamp (which is interpreted as local or global time depending on the scheduler).</p>
<p>The message is delivered immediately if the time is zero or less than the current time; however, to avoid unbounded recursion, messages scheduled within handlers are appended to a "pending
messages" queue and delivered after the handler returns. </p>

</div>
</div>
<a class="anchor" id="ga316a1d88c3c728d6c0a4ba49228a8f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_service_free </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a local service. </p>
<p>The #service_name corresponds to the parameter previously passed to <a class="el" href="group__basics.html#gacd22196d91300f33ba67d596549d2a69" title="Add a service to the current application. ">o2_service_new</a> or <a class="el" href="group__basics.html#gac4744322896863a159a920ce798fe718" title="Create a service that forwards O2 messages to an OSC server. ">o2_osc_delegate</a>. Note that if an OSC port forwards to this service (see <a class="el" href="group__basics.html#ga5a3dd4a4c5cb37fa0926848f57a86cd2" title="Create a port to receive OSC messages. ">o2_osc_port_new</a>), the port remains open, but the OSC messages will be dropped. See <a class="el" href="group__basics.html#gad4500742eecb51b9800c762dfb65348d" title="Remove a port receiving OSC messages. ">o2_osc_port_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>the name of the service</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#O2_SUCCSS if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd22196d91300f33ba67d596549d2a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_service_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a service to the current application. </p>
<p>Once created, services are "advertised" to other processes with matching application names, and messages are delivered accordingly. E.g. to handle messages addressed to "/synth/volume" you call </p><div class="fragment"><div class="line"><a class="code" href="group__basics.html#gacd22196d91300f33ba67d596549d2a69">o2_service_new</a>(<span class="stringliteral">&quot;synth&quot;</span>);</div><div class="line"><a class="code" href="group__basics.html#ga5681e480b085ea6552a2456f1a3709de">o2_method_new</a>(<span class="stringliteral">&quot;/synth/volume&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>, synth_volume_handler, NULL, NULL, TRUE);</div></div><!-- fragment --><p> and define <code>synth_volume_handler</code> (see the type declaration for <a class="el" href="group__basics.html#ga1c378242c7b1a32846b0bbbfa6d795a7" title="callback function to receive an O2 message ">o2_method_handler</a> and <a class="el" href="group__basics.html#ga5681e480b085ea6552a2456f1a3709de" title="Add a handler for an address. ">o2_method_new()</a>) Normally, services should be <em>unique</em> across the application. If #service_name is already locally defined in this process (by a previous call to <a class="el" href="group__basics.html#gacd22196d91300f33ba67d596549d2a69" title="Add a service to the current application. ">o2_service_new</a> or <a class="el" href="group__basics.html#gac4744322896863a159a920ce798fe718" title="Create a service that forwards O2 messages to an OSC server. ">o2_osc_delegate</a>), this call will fail, returning <a class="el" href="group__returncodes.html#ga7e7ac8498a39d0d9ffcaa505570795cb" title="an error return value: attempt to create a local service when one exists already ">O2_SERVICE_EXISTS</a>. If matching service names are defined in two different processes, the process with the highest IP and port number (lexicographically) will provide the service. However, due to the distributed and asynchronous nature of O2, there may be some intervening time (typically a fraction of a second) during which a service is handled by two different processes. Furthermore, the switch to a new service provider could redirect a stream of messages, causing unexpected behavior in the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>the name of the service</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga33bd6f43cf100d78b5e2282409fc63a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a> o2_set_discovery_period </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a>&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set discovery period. </p>
<p>O2 discovery messages are broadcast periodically in case a new process has joined the application. The default period is 4 seconds. If there are N processes, each host will receive N/4 discovery messages per second. Since there are 5 discovery ports, each process will handle N/20 discovery messages per second, and a discovery message from any given process will be received every 20 seconds. (Note, however, that new processes send more frequently, sending 2 discovery messages to each of the 5 discovery port numbers within 2 seconds, so if messages are not dropped frequently, discovery of new processes will happen much faster than the worst-case 20 second polling period or even the 10 second expected wait.)</p>
<p>You can change the polling period from 4s by calling this function. The new polling period takes effect when the next discovery message is sent at the end of the current polling period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the requested polling period; a minimum of 0.1s is enforced; 4s is the default (recommended).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous polling period </dd></dl>

</div>
</div>
<a class="anchor" id="ga46819340ca66f61bb17059e5542f763a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_status </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the status of the service. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>the name of the service </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if no service is found,</li>
<li><a class="el" href="group__returncodes.html#gafbebc6ebd6db0ab58a673502c46d2196" title="return value for o2_status(): local service, no clock sync yet ">O2_LOCAL_NOTIME</a> if the service is local but we have no clock sync yet,</li>
<li><a class="el" href="group__returncodes.html#gab65d15242eba537719936420ffea3766" title="return value for o2_status(): remote service but no clock sync yet ">O2_REMOTE_NOTIME</a> if the service is remote but we have no clock sync yet,</li>
<li><a class="el" href="group__returncodes.html#ga9574f9ef2e2e2076ce70158b8065b92a" title="return value for o2_status(): service is connected but no clock sync yet. ">O2_BRIDGE_NOTIME</a> if service is attached by a non-IP link, but we have no clock sync yet (if the non-IP connection is not handled by this process, the service status will be <a class="el" href="group__returncodes.html#gab65d15242eba537719936420ffea3766" title="return value for o2_status(): remote service but no clock sync yet ">O2_REMOTE_NOTIME</a>),</li>
<li><a class="el" href="group__returncodes.html#ga68ce31f5324da491a1f0ef28514277d9" title="return value for o2_status(): service is connected but no clock sync yet. ">O2_TO_OSC_NOTIME</a> if service forwards to an OSC server but we have no clock sync yet (if the OSC connection is not handled by this process, the service status will be <a class="el" href="group__returncodes.html#gab65d15242eba537719936420ffea3766" title="return value for o2_status(): remote service but no clock sync yet ">O2_REMOTE_NOTIME</a>),</li>
<li><a class="el" href="group__returncodes.html#gaab995c8652da0f9c9b093c1218a0910c" title="return value for o2_status(): local service with clock sync. ">O2_LOCAL</a> if service is local and we have clock sync,</li>
<li><a class="el" href="group__returncodes.html#ga4734fb75ba6972f958f09a027445a1f5" title="return value for o2_status(): remote service with clock sync. ">O2_REMOTE</a> if service is remote and we have clock sync,</li>
<li><a class="el" href="group__returncodes.html#ga632b32393049a19bbf6c43c112da82f5" title="return value for o2_status(): connected with clock sync. ">O2_BRIDGE</a> if service is handled locally by forwarding to an attached non-IP link, and we have clock sync. (If the non-IP connection is not local, the service status will be <a class="el" href="group__returncodes.html#ga4734fb75ba6972f958f09a027445a1f5" title="return value for o2_status(): remote service with clock sync. ">O2_REMOTE</a>).</li>
<li><a class="el" href="group__returncodes.html#gaf8c31b4fcc08f69cdd30751108fc044b" title="return value for o2_status(): connected with clock sync. ">O2_TO_OSC</a> if service is handled locally by forwarding to an OSC server and this process has clock sync. (If the OSC connection is not handled locally, the service status will be <a class="el" href="group__returncodes.html#ga4734fb75ba6972f958f09a027445a1f5" title="return value for o2_status(): remote service with clock sync. ">O2_REMOTE</a>).</li>
</ul>
</dd>
<dd>
Note that codes are carefully ordered to allow testing for categories:<ul>
<li>to test if delivery is possible with a zero (immediate) timestamp, use <code>o2_status(service) &gt; O2_FAIL</code>, <code>o2_status(service) &gt;= 0</code>, or <code>o2_status(service) &gt;= O2_LOCAL_NOTIME</code>.</li>
<li>to test if delivery is possible with a non-zero timestamp, use <code>o2_status(service) &gt;= O2_LOCAL</code>. Note that status can change over time, e.g. the status of a remote service will be <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> until the service is discovered. It will then change to <a class="el" href="group__returncodes.html#gab65d15242eba537719936420ffea3766" title="return value for o2_status(): remote service but no clock sync yet ">O2_REMOTE_NOTIME</a> until both the sender and receiver achieve clock synchronization and share their synchronized status, and finally the status will become <a class="el" href="group__returncodes.html#ga4734fb75ba6972f958f09a027445a1f5" title="return value for o2_status(): remote service with clock sync. ">O2_REMOTE</a>.</li>
</ul>
</dd></dl>
<p>In the cases with no clock sync, it is safe to send an immediate message with timestamp = 0, but non-zero timestamps are meaningless because either the sending process has no way to obtain a valid timestamp or the receiver has no way to schedule delivery according to a timestamp.</p>
<p>Messages to services are <em>dropped</em> if the service has not been discovered. Timestamped messages (timestamp != 0) are <em>dropped</em> if the sender and receiver are not clock-synchronized. (<code>o2_status(service) &gt;= O2_LOCAL</code>).</p>
<p>A special case is with <code>BRIDGE</code> and <code>OSC</code> services. In these cases, the O2 process offering the service can either schedule the messages locally, sending them according to the timestamp (and suffering some network latency), or if the destination process is synchronized, messages can be forwarded immediately for more precise scheduling at their final destination. O2 does not provide any way for clients/users to determine which of these methods is in effect, and in the case of messages being forwarded by an intermediary O2 process, the originator of the message cannot determine whether the service is offered by an O2 server on the local network, by an OSC server, or through a bridge to another network such as Bluetooth. The status at the originator will be simply <a class="el" href="group__returncodes.html#ga4734fb75ba6972f958f09a027445a1f5" title="return value for o2_status(): remote service with clock sync. ">O2_REMOTE</a> or <a class="el" href="group__returncodes.html#gab65d15242eba537719936420ffea3766" title="return value for o2_status(): remote service but no clock sync yet ">O2_REMOTE_NOTIME</a>.</p>
<p>When the status of a service changes, a message is sent with address <code>!_o2/si</code>. The type string is "sis" and the parameters are (1) the service name, (2) the new status, and (3) the ip:port string of the process that offers (or offered) the service. </p>

</div>
</div>
<a class="anchor" id="gac9323c695fd37d9a5ff063ee60493823"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_tap </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tappee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy messages from one service to another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tappee</td><td>the service to be tapped</td></tr>
    <tr><td class="paramname">tapper</td><td>the service to which copies are sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__returncodes.html#gabdd1c898b818fc47b744e42b401a3079" title="function was successful ">O2_SUCCESS</a> if success, <a class="el" href="group__returncodes.html#ga8f5f040b03042ee184f7f5bae734026d" title="an error return value: a non-specific error occurred. ">O2_FAIL</a> if not.</dd></dl>
<p>After this call, messages to tappee are copied, modified by replacing the service with tapper, and sent. The original message to tappee is also delivered. </p>

</div>
</div>
<a class="anchor" id="ga10db3d64aa464498b6b8b90c28b7996d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__basics.html#gaa38553f092bb619d41d5b13020bcc21d">o2_time</a> o2_time_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the estimated synchronized global O2 time. </p>
<p>This function returns a valid value either after you call <a class="el" href="group__basics.html#gadd34ca951dd2889063c3167e90799732" title="Provide a time reference to O2. ">o2_clock_set()</a>, making the local clock the master clock for the O2 application, or after O2 has finished discovering and synchronizing with the master clock. Until then, -1 is returned.</p>
<p>The clock accuracy depends upon network latency, how often <a class="el" href="group__basics.html#ga086b104222177b13c3d8e2b47ec9bf28" title="Process current O2 messages. ">o2_poll()</a> is called, and other factors, but</p>
<dl class="section return"><dt>Returns</dt><dd>the time in seconds, or -1 if global (master) time is unknown. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga91fe84d524309a27b579ea169d5816ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">o2_sched_ptr o2_active_sched</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current scheduler. </p>
<p>When a timed message is delivered by a scheduler, <a class="el" href="group__basics.html#ga91fe84d524309a27b579ea169d5816ae" title="Current scheduler. ">o2_active_sched</a> is set to pount to the scheduler. A handler that constructs and schedules a message can use this pointer to continue using the same scheduler. </p>

</div>
</div>
<a class="anchor" id="gaa3e8255411b99815dcb37bd5da8b0427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* o2_application_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>name of the application </p>
<p>A collection of cooperating O2 processes forms an <em>application</em>. Applications must have unique names. This allows more than one application to exist within a single network without conflict. For example, there could be two applications, "joe" and "sue", each with services named "synth." Since the application names are different, joe's messages to the synth service go to joe's synth and not to sue's synth.</p>
<p>Do not set, modify or free this variable! Consider it to be read-only. It is managed by O2 using <a class="el" href="group__basics.html#ga54991832ea34fc9a0a14b5a6669c3e6c" title="Start O2. ">o2_initialize()</a> and <a class="el" href="group__basics.html#gaeb0a8ba7f6be0f8f95ad7e7803fa0698" title="release the memory and shut down O2. ">o2_finish()</a>. </p>

</div>
</div>
<a class="anchor" id="ga12a5538a2b701920639e89be06ad8d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">o2_sched o2_gtsched</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduler that schedules according to global (master) clock time. </p>
<p>Scheduling on this scheduler (including sending timed messages) will only work after clock synchronization is obtained. Until then, timed message sends will fail and attempts to <a class="el" href="group__basics.html#ga2bb3e18653c5cd78174042c75e7da8b2">o2_schedule()</a> will fail. </p>

</div>
</div>
<a class="anchor" id="ga65a8e27a3d04e922c4903e54f3399752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">o2_sched o2_ltsched</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduler that schedules according to local clock time. </p>
<p>It may be necessary to schedule events before clock synchronization with the master clock, or you may want to schedule local processing that ignores any changes in clock time or clock speed needed to stay synchronized with the master clock (even though these should be small). For example, O2 uses the local time scheduler to schedule the clock synchronization protocol, which of course must run before clock synchronization is obtained.</p>
<p>In these cases, you should schedule messages using <a class="el" href="group__basics.html#ga65a8e27a3d04e922c4903e54f3399752" title="Scheduler that schedules according to local clock time. ">o2_ltsched</a>. </p>

</div>
</div>
<a class="anchor" id="ga0148f5dab667f58540f2f2ce1074aa88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int o2_stop_flag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set this flag to stop <a class="el" href="group__basics.html#ga98cc834b5c8ee8200729ae0ec93f6a4e" title="Run O2. ">o2_run()</a> </p>
<p>Some O2 applications will initialize and call <a class="el" href="group__basics.html#ga98cc834b5c8ee8200729ae0ec93f6a4e" title="Run O2. ">o2_run()</a>, which is a simple loop that calls <a class="el" href="group__basics.html#ga086b104222177b13c3d8e2b47ec9bf28" title="Process current O2 messages. ">o2_poll()</a>. To exit the loop, set <a class="el" href="group__basics.html#ga0148f5dab667f58540f2f2ce1074aa88" title="set this flag to stop o2_run() ">o2_stop_flag</a> to #TRUE </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
